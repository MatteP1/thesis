\documentclass[twoside,11pt,openright]{report}

\usepackage[latin1]{inputenc}
\usepackage[american]{babel}
\usepackage{a4}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{epsfig}
\usepackage[T1]{fontenc}
\usepackage{mathptmx}
\usepackage{color}
\usepackage{epstopdf}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage[useregional]{datetime2}
\DTMlangsetup[en-US]{showdayofmonth=false}
\usepackage{lipsum}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{iris}
\usepackage{heaplang}
\usepackage{tikz}
\usetikzlibrary{calc,shapes.multipart,chains,arrows}

\renewcommand*\sfdefault{lmss}
\renewcommand*\ttdefault{txtt}

% Theorems, Corollaries, and Lemmas
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\newtheorem{definition}{Definition}[section]


\newcommand{\isLock}{\operatorname{isLock}}
\newcommand{\locked}{\operatorname{locked}}
\newcommand{\issued}{\operatorname{issued}}
\newcommand{\newLock}{\operatorname{newLock}}
\newcommand{\acquire}{\operatorname{acquire}}
\newcommand{\wait}{\operatorname{wait}}
\newcommand{\release}{\operatorname{release}}
\newcommand{\lockInv}{\operatorname{lockInv}}
\newcommand{\initialise}{\operatorname{initialize}}
\newcommand{\enqueue}{\operatorname{enqueue}}
\newcommand{\dequeue}{\operatorname{dequeue}}

\newcommand{\isqueue}{\operatorname{is\_queue}}

\newcommand{\isLLchain}[1]{\operatorname{isLL\_chain} \; #1}
\newcommand{\isLL}{\operatorname{isLL}}

\newcommand{\locin}[1]{\loc_{#1\_\text{in}}}
\newcommand{\locout}[1]{\loc_{#1\_\text{out}}}

\newcommand{\nIn}[1]{\operatorname{in} \; #1}
\newcommand{\nVal}[1]{\operatorname{val} \; #1}
\newcommand{\nOut}[1]{\operatorname{out} \; #1}

\newcommand\catenate{\mathbin{\text{\ttfamily\upshape ++}}}

\newcommand{\todo}[1]{{\color[rgb]{.5,0,0}\textbf{$\blacktriangleright$#1$\blacktriangleleft$}}}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{empty}
\pagenumbering{roman} 
\vspace*{\fill}\noindent{\rule{\linewidth}{1mm}\\[4ex]
{\Huge\sf TITLE HERE}\\[2ex]
{\huge\sf Mathias Pedersen, 201808137}\\[2ex]
\noindent\rule{\linewidth}{1mm}\\[4ex]
\noindent{\Large\sf Master's Thesis, Computer Science\\[1ex] 
\today \\[1ex] Advisor: Amin Timany\\[15ex]}\\[\fill]}
\epsfig{file=logo.eps}\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{plain}
\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}

\todo{in English\dots}

\chapter*{Resum\'e}
\addcontentsline{toc}{chapter}{Resum\'e}

\todo{in Danish\dots}

\chapter*{Acknowledgments}
\addcontentsline{toc}{chapter}{Acknowledgments}

\todo{\dots}

\vspace{2ex}
\begin{flushright}
  \emph{Mathias Pedersen}\\
  \emph{Aarhus, \today.}
\end{flushright}

\tableofcontents
\cleardoublepage
\pagenumbering{arabic}
\setcounter{secnumdepth}{2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}
\label{ch:intro}

\todo{motivate and explain the problem to be addressed}

\todo{example of a citation: \cite{DBLP:conf/podc/MichaelS96}}
\todo{get your bibtex entries from \url{https://dblp.org/}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Preliminaries}
\label{ch:preliminaries}
\todo{Description of HeapLang, Iris, Verified in Coq (Weakest precondition vs Hoare triples)}

\chapter{The Two-Lock Michael Scott Queue}

I present here he an implementation of the Two-lock MS-Queue in HeapLang. This implementation differs slightly from the original, presented in \cite{DBLP:conf/podc/MichaelS96}, but most changes simply reflect the differences in the two languages.


\section{Preliminaries}

The underlying data structure making up the queue is a singly-linked list. The linked-list will always contain at least one element, called the \emph{sentinel} node, marking the beginning of the queue. Note that the sentinel node is itself not part of the queue, but all nodes following it are. The queue keeps a head pointer ($\loc_{head}$) which always points to the sentinel, and a tail pointer ($\loc_{tail}$) which points to some node in the linked list.

In my implementation, a node can be thought of as a triple $(\locin{i}, v_i, \locout{i})$. The location $\locin{i}$ points to the pair $(v_i, \locout{i})$, where $v_i$ is the value of the node, and $\locout{i}$ either points to $\None$ which represents the null pointer, or to the next node in the linked list. When we say that a location $\loc$ points to a node $(\locin{i}, v_i, \locout{i})$, we mean that $\loc \mapsto \locin{i}$. Hence, if we have two adjacent nodes $(\locin{i}, v_i, \locout{i})$, $(\locin{i+1}, v_{i+1}, \locout{i+1})$ in the linked list, then we have the following structure: $\locin{i} \mapsto (v_i, \locout{i})$, $\locout{i} \mapsto \locin{i+1}$, and $\locin{i+1} \mapsto v_{i+1}, \locout{i+1}$.

The reader may wonder why there is an extra, intermediary "in" pointer, between the pairs of the linked list, and why the "out" pointer couldn't point directly to the next pair. In the original implementation \cite{DBLP:conf/podc/MichaelS96}, nodes are allocated on the heap. To simulate this in HeapLang, when creating a new node, we create a pointer to a pair making up the node. Now, in the C-like language used in the original specification, an assignment operator is available which is not present in HeapLang. So in order to mimic this behaviour, we model variables as pointers. In this way, we can model a variable $\lvarA$ as a location $\loc_{\lvarA}$, and the value stored at $\loc_{\lvarA}$ is the current value of $\lvarA$. This means that the variable $\locout{i}$ (called "next" in the original) becomes a location $\loc_{head}$, and the value stored at the location is what head is currently assigned to. Since $\locout{i}$ is supposed to be a variable containing a pointer, then the value saved at that location will also be a pointer.


\section{implementation}\label{section:two_lock:impl}

The queue consists of 3 functions: $\initialise$, $\enqueue$, and $\dequeue$ which I now present in turn.

\subsection[initialise]{$\initialise$}

$\initialise$ will first create a single node -- the sentinel -- marking the start of the linked list. It then creates two locks, $H\_lock$ and $T\_lock$, protecting the head and tail pointers, respectively. Finally, it creates the head and tail pointers, both pointing to the sentinel. The queue is then a pointer to a structure containing the head, the tail, and the two locks.\\
Figure \ref{MSQTL:impl:figure:init} illustrates the structure of the queue after initialisation. Note that one of the pointers is coloured blue. This represents a \emph{persistent} pointer; a pointer that will never be updated again. All "in" pointers $\locin{i}$, are persistent, meaning that they will always point to $(v_i, \locout{i})$. We shall use the notation $\loc \mapsto \square v$ (introduced in \cite{DBLP:conf/cpp/VindumB21}) to mean that $\loc$ points persistently to $v$.

Note that in the original specification, a queue is a pointer to a 4-tuple $(\loc_{head}, \loc_{tail}, H\_lock, T\_lock)$. Since HeapLang doesn't support 4-tuples, we instead represent the queue as a pointer to a pair of pairs: $((\loc_{head}, \loc_{tail}), (H\_lock, T\_lock))$.


\subsection[enqueue]{$\enqueue$}

To enqueue a value, we must create a new node, append it to the underlying linked-list, and swing the tail pointer to this new node. These three operations are depicted in figure \ref{MSQTL:impl:figure:enqueue}.

$\enqueue$ takes as argument the value to be enqueued and creates a new node containing this value (corresponding to figure \ref{MSQTL:impl:figure:enqueue:a}). This creation doesn't interact with the underlying queue data-structure, hence why we don't acquire the $T\_lock$ first. After creating the new node, we must make the last node in the linked list point to it. Since this operation interacts with the queue, we first acquire the $T\_lock$. Once we obtain the lock, we make the last node in the linked list point to our new node (figure \ref{MSQTL:impl:figure:enqueue:b}). Following this, we swing $\loc_{tail}$ to the new last node in the linked list (figure \ref{MSQTL:impl:figure:enqueue:c}).

Figure \ref{MSQTL:impl:figure:enqueue} also illustrates when pointers become persistent; once the previous last node is updated to point to the newly inserted node, that pointer will never be updated again, hence becoming persistent.

\subsection[dequeue]{$\dequeue$}

It is of course only possible to dequeue an element from the queue if the queue contains at least one element. Hence, the first thing $\dequeue$ does is check if the queue is empty. We can detect an empty queue by checking if the sentinel is the last node in the linked list. Being the last node in the linked list corresponds to having the "out" node be $\None$. If this is the case, then the queue is empty and the code returns $\None$. Otherwise, there is a node just after the sentinel, which is the first node of the queue. To dequeue it, we first read the associated value, and next we swing the head to it, making it the new sentinel. Finally, we return the value we read.

Since all of these operations interact with the queue, we shall only perform them after having acquired $H\_lock$.

Figure \ref{MSQTL:impl:figure:dequeue} illustrates running dequeue on a non-empty queue. Note that the only change is that the head pointer is swung to the next node in the linked list; the old sentinel is not deleted, it just become unreachable from the heap pointer. In this way, the linked list only ever grows.

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[
    pair/.style = {
      on chain,
      rectangle split,
      rectangle split horizontal,
      rectangle split parts=2,
      draw,
      anchor=center,
      text height=1.5ex,
    },
    perspointer/.style = {
      on chain,
      rectangle,
      draw,
      anchor=center,
      text height=1.5ex,
    },
    pointer/.style = {
      rectangle,
      draw,
      anchor=center,
      text height=1.5ex,
    },
    start chain=going right,
  ]

  % Linked List
  \node (l'1) [join={by ->}, perspointer,on chain] {$\locin{1}$};
  \node (l1pair) [join={by ->, draw=blue}, pair,on chain] {$\None$ \nodepart{two} $\locout{1}$};
  \node (null) [join={by ->, draw=black}, rectangle,on chain] {$\None$};

  % Head and tail
  \node (head) [pointer, above left=of l'1] {$\loc_{head}$};
  \node (tail) [pointer, above right=of l'1] {$\loc_{tail}$};
  \draw[->] (head) -- (l'1);
  \draw[->] (tail) -- (l'1);
  
  \end{tikzpicture}
  \caption{Queue after initialisation}
  \label{MSQTL:impl:figure:init}
\end{figure}


\begin{figure}[h]
  \centering
  \begin{subfigure}{\textwidth}
    \begin{tikzpicture}[
      pair/.style = {
        on chain,
        rectangle split,
        rectangle split horizontal,
        rectangle split parts=2,
        draw,
        anchor=center,
        text height=1.5ex,
      },
      perspointer/.style = {
        on chain,
        rectangle,
        draw,
        anchor=center,
        text height=1.5ex,
      },
      pointer/.style = {
        rectangle,
        draw,
        anchor=center,
        text height=1.5ex,
      },
      start chain=going right,
    ]
  
    % Linked List
    \node (l'1) [join={by ->}, perspointer,on chain] {$\locin{1}$};
    \node (l1pair) [join={by ->, draw=blue}, pair,on chain] {$v_1$ \nodepart{two} $\locout{1}$};
    \node (l'2) [join={by ->, draw=blue}, perspointer,on chain] {$\locin{2}$};
    \node (l2pair) [join={by ->, draw=blue}, pair,on chain] {$v_2$ \nodepart{two} $\locout{2}$};
    \node (null) [join={by ->, draw=black}, rectangle,on chain] {$\None$};
  
    \node (l'3) [perspointer, above right=of l2pair] {$\locin{3}$};
    \node (l3pair) [join={by ->, draw=blue}, pair,on chain] {$v_3$ \nodepart{two} $\locout{3}$};
    \node (null) [join={by ->, draw=black}, rectangle,on chain] {$\None$};
  
    % Head and tail
    \node (head) [pointer, above=of l'1] {$\loc_{head}$};
    \node (tail) [pointer, above=of l'2] {$\loc_{tail}$};
    \draw[->] (head) -- (l'1);
    \draw[->] (tail) -- (l'2);
    
    \end{tikzpicture}
    \caption{Queue after creating the new node $(\locin{3}, v_3, \locout{3})$ to be added to the queue.}
    \label{MSQTL:impl:figure:enqueue:a}
    \vspace{2em}
  \end{subfigure}
  \begin{subfigure}{\textwidth}
    \begin{tikzpicture}[
      pair/.style = {
        on chain,
        rectangle split,
        rectangle split horizontal,
        rectangle split parts=2,
        draw,
        anchor=center,
        text height=1.5ex,
      },
      perspointer/.style = {
        on chain,
        rectangle,
        draw,
        anchor=center,
        text height=1.5ex,
      },
      pointer/.style = {
        rectangle,
        draw,
        anchor=center,
        text height=1.5ex,
      },
      start chain=going right,
    ]
  
    % Linked List
    \node (l'1) [join={by ->}, perspointer,on chain] {$\locin{1}$};
    \node (l1pair) [join={by ->, draw=blue}, pair,on chain] {$v_1$ \nodepart{two} $\locout{1}$};
    \node (l'2) [join={by ->, draw=blue}, perspointer,on chain] {$\locin{2}$};
    \node (l2pair) [join={by ->, draw=blue}, pair,on chain] {$v_2$ \nodepart{two} $\locout{2}$};
    \node (null) [join={by ->, dotted, draw=black}, rectangle,on chain] {\textcolor{gray}{$\None$}};
  
    \node (l'3) [perspointer, above right=of l2pair] {$\locin{3}$};
    \node (l3pair) [join={by ->, draw=blue}, pair,on chain] {$v_3$ \nodepart{two} $\locout{3}$};
    \node (null) [join={by ->, draw=black}, rectangle,on chain] {$\None$};
    \draw[->, draw=blue] (l2pair) -- (l'3);
  
    % Head and tail
    \node (head) [pointer, above=of l'1] {$\loc_{head}$};
    \node (tail) [pointer, above=of l'2] {$\loc_{tail}$};
    \draw[->] (head) -- (l'1);
    \draw[->] (tail) -- (l'2);
    
    \end{tikzpicture}
    \caption{Queue after adding the new node to linked list.}
    \label{MSQTL:impl:figure:enqueue:b}
    \vspace{2em}
  \end{subfigure}
  \begin{subfigure}{\textwidth}
    \begin{tikzpicture}[
      pair/.style = {
        on chain,
        rectangle split,
        rectangle split horizontal,
        rectangle split parts=2,
        draw,
        anchor=center,
        text height=1.5ex,
      },
      perspointer/.style = {
        on chain,
        rectangle,
        draw,
        anchor=center,
        text height=1.5ex,
      },
      pointer/.style = {
        rectangle,
        draw,
        anchor=center,
        text height=1.5ex,
      },
      start chain=going right,
    ]
  
    % Linked List
    \node (l'1) [join={by ->}, perspointer,on chain] {$\locin{1}$};
    \node (l1pair) [join={by ->, draw=blue}, pair,on chain] {$v_1$ \nodepart{two} $\locout{1}$};
    \node (l'2) [join={by ->, draw=blue}, perspointer,on chain] {$\locin{2}$};
    \node (l2pair) [join={by ->, draw=blue}, pair,on chain] {$v_2$ \nodepart{two} $\locout{2}$};
    \node (null) [join={by ->, dotted, draw=black}, rectangle,on chain] {\textcolor{gray}{$\None$}};
  
    \node (l'3) [perspointer, above right=of l2pair] {$\locin{3}$};
    \node (l3pair) [join={by ->, draw=blue}, pair,on chain] {$v_3$ \nodepart{two} $\locout{3}$};
    \node (null) [join={by ->, draw=black}, rectangle,on chain] {$\None$};
    \draw[->, draw=blue] (l2pair) -- (l'3);
  
    % Head and tail
    \node (head) [pointer, above=of l'1] {$\loc_{head}$};
    \node (tail) [pointer, above=of l'2] {$\loc_{tail}$};
    \draw[->] (head) -- (l'1);
    \draw[->, dotted] (tail) -- (l'2);
    \draw[->] (tail) -- (l'3);
    
    \end{tikzpicture}
    \caption{Queue after swinging tail pointer to the new node.}
    \label{MSQTL:impl:figure:enqueue:c}
  \end{subfigure}
  \caption{Enqueuing an element to a queue with one element.}
  \label{MSQTL:impl:figure:enqueue}
\end{figure}


\begin{figure}[h]
  \centering
  \begin{tikzpicture}[
    pair/.style = {
      on chain,
      rectangle split,
      rectangle split horizontal,
      rectangle split parts=2,
      draw,
      anchor=center,
      text height=1.5ex,
    },
    perspointer/.style = {
      on chain,
      rectangle,
      draw,
      anchor=center,
      text height=1.5ex,
    },
    pointer/.style = {
      rectangle,
      draw,
      anchor=center,
      text height=1.5ex,
    },
    start chain=going right,
  ]

  % Linked List
  \node (l1in) [join={by ->}, perspointer,on chain] {$\locin{1}$};
  \node (l1pair) [join={by ->, draw=blue}, pair,on chain] {$v_1$ \nodepart{two} $\locout{1}$};
  \node (l2in) [join={by ->, draw=blue}, perspointer,on chain] {$\locin{2}$};
  \node (l2pair) [join={by ->, draw=blue}, pair,on chain] {$v_2$ \nodepart{two} $\locout{2}$};
  \node (l3in) [join={by ->, draw=blue}, perspointer,on chain] {$\locin{3}$};
  \node (l3pair) [join={by ->, draw=blue}, pair,on chain] {$v_3$ \nodepart{two} $\locout{3}$};
  \node (null) [join={by ->, draw=black}, rectangle,on chain] {$\None$};

  % Head and tail
  \node (head) [pointer, above=of l1pair] {$\loc_{head}$};
  \node (tail) [pointer, above=of l3in] {$\loc_{tail}$};
  \draw[->, dotted] (head) -- (l1in);
  \draw[->, dashed] (head) -- (l2in);
  \draw[->] (tail) -- (l3in);
  
  \end{tikzpicture}
  \caption{Dequeueing an element ($v_2$) from a queue with two elements ($v_2$, $v_3$). The dotted line represents the state before the dequeue, and the dashed line is the state after dequeuing.}
  \label{MSQTL:impl:figure:dequeue}
\end{figure}


\begin{align*}
  \langkw{let} \initialise := &\\
                    & \Let node = \Ref((\None, \Ref(\None))) in\\
                    & \Let H\_lock = newlock \TT in\\
                    & \Let T\_lock = newlock \TT in\\
                    & \Ref ((\Ref(node), \Ref(node)), (H\_lock, T\_lock))
\end{align*}

\begin{align*}
  \langkw{let} \enqueue \ Q \ value :=&\\
		& \Let node = \Ref ((\Some value, \Ref(\None))) in\\
		& \acquire (\Snd (\Snd (\deref Q)));\\
		& \Snd (\deref(\deref(\Snd (\Fst(\deref Q))))) \gets node;\\
		& \Snd (\Fst (\deref Q)) \gets node;\\
		& \release (\Snd (\Snd (\deref Q)))
\end{align*}

\begin{align*}
  \langkw{let} \dequeue \ Q :=&\\ 
		& \acquire (\Fst (\Snd (\deref Q)));\\
		& \Let node = \deref (\Fst (\Fst (\deref Q))) in\\
		& \Let new\_head = \deref (\Snd(\deref node)) in\\
		& \If new\_head = \None then\\
			& \hspace{20pt} \release (\Fst (\Snd(\deref Q)));\\
			& \hspace{20pt} \None\\
		& \Else\\
			& \hspace{20pt} \Let value = \Fst (\deref new\_head) in\\
			& \hspace{20pt} \Fst (\Fst (\deref Q)) \gets new\_head;\\
			& \hspace{20pt} \release (\Fst (\Snd (\deref Q)));\\
      & \hspace{20pt} value
\end{align*}


\section{Sequential Specification}

Let us first prove a specification for the two-lock michael scott queue in the simple case where we don't allows for concurrency. In this case, we know that only a single thread will interact with the queue at any given point in a sequential manner. This means that we give a specification that tracks the exact contents of the queue. To this end, we shall define the abstract state of the queue, denoted $xs_v$ as a list of HeapLang values. I.e. $xs_v : \List \ \Val$. We adopt the convention that enqueueing an element is done by adding it to the front of the list, and dequeueing removes the last element of the list (if such an element exists). The reason for this choice is purely technical.

Since the queue uses two locks, we will get two ghost names; one for each lock. For this specification, these are the only two ghost names we will need. However, for the later specifications, we will use more resource algebra, and will need more ghost names. Thus, to ease notation, we shall define the type "$Qgnames$" whose purpose is to keep track of the ghost names used for a specific queue. Since we only have two ghost names for this specification, element of $Qgnames$ will simply be pairs. For an element $Q_\gname \in Qgnames$, the first element of the pair, written $Q_\gname.\gname_{Hlock}$, will contain the ghost name for the head lock, and the second element, $Q_\gname.\gname_{Tlock}$, the ghost name for the head lock.

The sequential specification we wish to prove is the following:
\begin{align*}
  &\exists \isqueue : \Val \to \List \ \Val \to Qgnames \to \Prop.\\
  &\quad\quad\hoare{\TRUE}{\initialise \TT}{v . \exists Q_\gname, \isqueue\ v\ []\ Q_\gname}\\
  &\land\quad\forall q, v, xs_v, Q_\gname. \hoare{\isqueue \; q \; xs_v \; Q_\gname}{\enqueue\ q\ v}{w . \isqueue\ q\ (v :: xs_v)\ Q_\gname}\\
  &\land\quad\forall q, xs_v, Q_\gname. \hoare{\isqueue \; q \; xs_v \; Q_\gname}{\dequeue\ q}{v . \begin{array}{l}(xs_v = [] \ast v = \None \ast \isqueue\ q\ xs_v\ Q_\gname) \; \lor\\ (\exists x_v, xs_v' \ . \ xs_v = xs_v' \catenate [x_v] \ast v = \Some x_v \ast \isqueue\ q\ xs_v'\ Q_\gname) \end{array}}
\end{align*}

The predicate $\isqueue \; q \; xs_v \; Q_\gname$ captures that the value $q$ is a queue, whose content matches that of our abstract representation $xs_v$, and the queue uses the ghost names described by $Q_\gname$. Note that the $\isqueue$ predicate is not required to be persistent, hence it cannot be duplicated and given to multiple threads. This is the sense in which this specification is sequential.

\section{Proving the Sequential Specification}
\subsection[The isqueue predicate]{The $\isqueue$ Predicate}
To prove the specification we must give a specific $\isqueue$ predicate. To help guide us in designing this, we give the following observations about the behaviour of the implementation.
\begin{enumerate}
  \item\label{MSQTL:insights:head} Head always points to the first node in the queue.
  \item\label{MSQTL:insights:tail} Tail always points to either the last or second last node in the queue.
  \item\label{MSQTL:insights:persistent} All but the last pointer in the queue (the pointer to $\None$) never change.
\end{enumerate}

Observation \ref{MSQTL:insights:tail} captures the fact that, while enqueueing, a new node is first added to the linked list, and then later the tail is updated to point to the newly added node. Since only one thread can enqueue a node at a time (due to the lock), then the tail will only ever point to the last or second last due to the above. However, in a sequential setting, the tail will always appear to point to the last node, as no one can inspect the queue while the tail points to the second last.

Insight \ref{MSQTL:insights:persistent} means that we can mark all pointers in the queue (except the pointer to the null node) as persistent. This is technically not needed in the sequential case, but we will incorporate it now, as we will need it in the concurrent setting.

\begin{align*}
  \isqueue \; q \; xs_v \; Q_\gname = &\exists \loc_{queue}, \loc_{head}, \loc_{tail} \in \Loc . \exists H_{lock}, T_{lock} \in \Val . \\
  &q = \loc_{queue} \ast \loc_{queue} \mapsto\persistently ((\loc_{head}, \loc_{tail}), (H_{lock}, T_{lock})) \ast\\
  &\exists xs_{queue} \in \List (\Loc \times \Val \times \Loc) . \exists x_{head}, x_{tail} \in (\Loc \times \Val \times \Loc) .\\
	&proj\_val \ xs_{queue} = wrap\_some \ xs_v \ast\\
	&\isLL (xs_{queue} ++ [x_{head}]) \ast\\
	&\loc_{head} \mapsto (\nIn{x_{head}}) \ast\\
	&\loc_{tail} \mapsto (\nIn{x_{tail}}) \ast isLast \ x_{tail} \ (xs_{queue} ++ [x_{head}]) \ast\\
	&isLock \ Q_\gname.\gname_{Hlock} \ H_{lock} \ \TRUE \ast\\
	&isLock \ Q_\gname.\gname_{Tlock} \ T_{lock} \ \TRUE.
\end{align*}

This $\isqueue$ predicate states that the value $q$ is a location, which always points to the structure containing the head, the tail, and the two locks. It also connects the abstract state $xs_v$ with the concrete state (represented by $xs_{queue}$), by stating that if you strip away the locations connecting the nodes and remove the $\Some$ around the values, then you get the abstract state $xs_v$. Next, the predicate specifies the concrete state. There is some head node $x_{head}$, which the head points to. This head node and the nodes in $xs_{queue}$ form the underlying linked list (specified using the $\isLL$ predicate below). There is also a tail node, which is the last node in the linked list, and the tail points to this node.
Finally, we have the isLock predicate for our two locks. Since we are in a sequential setting, then the locks are superfluous, hence they simply protect $\TRUE$.

The $\isLL$ predicate essentially creates the structure seen in the examples of section \ref{section:two_lock:impl}. It is defined in two steps. Firstly, we create all the persistent pointers in the linked list using the $\isLLchain$ predicate. Note that this in effect makes $\isLLchain \ xs$ persistent for all $xs$.
\begin{definition}[Linked List Chain Predicate]
  \begin{align*}
    \isLLchain{[]} \equiv& \TRUE\\
    \isLLchain{[x]} \equiv& \nIn{x} \mapsto\square (\nVal{x}, \nOut{x})\\
    \isLLchain{x :: x' :: xs} \equiv& \nIn{x} \mapsto\square (\nVal{x}, \nOut{x}) \ast \nOut{x'} \mapsto\square \nIn{x} \ast \isLLchain{x' :: xs}
  \end{align*}
\end{definition}

Then, to define $\isLL$, we add that the last node in the linked list points to $\None$.
\begin{definition}[Linked List Predicate]
  \begin{align*}
    \isLL{[]} \equiv& \TRUE\\
    \isLL{x :: xs} \equiv& \nOut{x} \mapsto \None \ast \isLLchain{x :: xs}
  \end{align*}
\end{definition}

\subsection{Proof outline}

\subsubsection{initialise}
Proving the initialise spec amounts to stepping through the code, giving us the required resources, and then using these to create an instance of $\isqueue$ with the obtained resources. To begin with, we step through the lines creating the first node, giving us locations $\locin{1}$, $\locout{1}$ with $\locout{1} \mapsto \None$ and $\locin{1} \mapsto (\None, \locout{1})$. We can then update the later points-to predicate to become persistent, giving us $\locin{1} \mapsto\persistent (\None, \locout{1})$. We then step to the creation of the two locks, where we shall use the newlock specification asserting that the locks should protect $\TRUE$. This gives us two ghost names, $\gname_{Tlock}$, $\gname_{Tlock}$, which we will collect in a $Qgnames$ pair, $Q_\gname$.
Next, we step through the allocations of the head, tail, and queue, which gives us locations $\loc_{head}$, $\loc_{tail}$, $\loc_{queue}$, such that both $\loc_{head}$ and $\loc_{tail}$ point to node $1$, and such that $\loc_{queue}$ points to the structure containing the head, tail, and two locks. This last points to predicate we update to become persistent.
With this, we now have all the resources needed to prove the post-condition: $\exists Q_\gname . \isqueue \ \loc_{queue} \ Q_\gname$. Proving this follows by a sequence of framing away the resources we obtained and instantiating existentials with the values we got above. Most noteworthy, we pick the empty list for $xs_{queue}$, and node $1$ for $xs_{head}$ and $xs_{tail}$.


\subsubsection{Enqueue}
\todo{add line numbers to code, and refer to them in proof}
For enqueue, we get in our pre-condition $\isqueue \; q \; xs_v \; Q_\gname$, and we wish to that, if we run $\enqueue\ q\ v$, then we will get the $\isqueue\ q\ (v :: xs_v)\ Q_\gname$. The proposition $\isqueue \; q \; xs_v \; Q_\gname$ gives us all the resources we will need to step through the code.
Firstly, we create a new node, node $x_{new}$, with $\nVal{x_{new}} = v$.
We then have to acquire the lock, which will just give us $\TRUE$.

The next line adds node $x_new$ to the linked list, by first finding the tail, from the queue pointer $\loc_{queue}$, and then finding the node that the tail points to, denoted $x_{tail}$, and finally writing updating the out location of $x_{tail}$ to point to $x_new$. The resources needed to do this are all described in $\isqueue \; q \; xs_v \; Q_\gname$. Firstly, it tells us that $\loc_{queue}$ points to the structure containing $\loc_{tail}$. Secondly, it tells us that $\loc_{tail}$ points to $x_{tail}$, which is the last node in the linked list ($xs_{queue} ++ [x_{head}]$). Thirdly, since we know that $x_{tail}$ is the last node in the linked list, then by the $\isLL$ predicate, we know that $x_{tail}$ points to $\None$ and that it has the node-like structure described by $\isLLchain$. This is all we need to step through the line, adding $x_{new}$ to the linked list. After performing the write, we then get that $x_{tail}$ points to $x_{new}$, instead of $\None$. We make this points-to predicate persistent.

The next line swings the tail to $x_{new}$. As describe above, we already know that $\loc_{tail}$ points to $x_{tail}$, so we have the required resources to perform the write. Afterwards, we get that $\loc_{tail}$ points to $x_{new}$.

Finally, we release the lock using the release specification (and we simply give back $\TRUE$), and the only thing left is to prove the postcondition: $\isqueue\ q\ (v :: xs_v)\ Q_\gname$. For the existentials, we shall pick the ones we got from the precondition, with the exception for $xs_{queue}$ and $x_{tail}$. For $xs_{queue}$, we shall use the same $xs_{queue}$ we got from the precondition, but with $xs_new$ cons'ed to it, and for $x_{tail}$, we chose the new tail node: $x_{new}$. With these choices, proving $\isqueue\ q\ (v :: xs_v)\ Q_\gname$ is fairly straightforward.

\subsubsection{Dequeue}

For $\dequeue\ q$, our precondition is $\isqueue \; q \; xs_v \; Q_\gname$, and we our post condition states that either the queue is empty, or there is a tail element which is returned by the function, and removed from the queue.

Stepping through the function, we first do the superfluous acquire. Next, we get the head node $x_{head}$ through the queue pointer $\loc_{queue}$. As described above for Enqueue, we get the resource to do this through $\isqueue \; q \; xs_v \; Q_\gname$. The $\isqueue$ predicate also tells us that $x_{head}$ is a node in the linked list (described by the $\isLL$ predicate), hence we can step through the code in the next line, which finds the node that $x_{head}$ is pointing to. Now, depending on whether or not the queue is empty, $x_{head}$ either points to $\None$, or some node $x_{head\_next}$. Thus, we shall perform a case analysis on $xs_{queue}$.

\textbf{$xs_{queue}$ is empty}: In this case, we will have that $\isLL [x_{head}]$, which tells us that $x_head$ points to $\None$. Hence, the "then" branch of the "if" will be taken. This branch simply releases the lock and returns $\None$. In this case, we prove the first disjunction in the post-condition. Since $xs_v$ is reflected in $xs_{queue}$, then we will be able to conclude that $xs_v$ is empty, and since we haven't modified the queue, we can create $\isqueue \; q \; xs_v \; Q_\gname$ using the same resources we got from the pre-condition.

\textbf{$xs_{queue}$ is not empty}: In this case, we can conclude that there must be some node $x_{head\_next}$, which is the first node in $xs_{queue}$. I.e. $xs_{queue} = xs'_{queue} ++ [x_{head\_next}]$. We can thus use the $\isLL$ predicate to conclude that $x_{head}$ must point to $x_{head\_next}$. Hence the else branch will be taken. Since $x_{head\_next}$ is part of the linked list, then $\isLL$ tells us it has the node-like structure, allowing us to extract its value in the first line of the else branch.\\
In the next line, we make the head pointer, $\loc_{head}$ point to $x_{head\_next}$, and we have the resource to do this through $\isqueue \; q \; xs_v \; Q_\gname$.\\
Finally, we release the lock and return the value we got from $x_{head\_next}$. We must now prove the post-condition, and this time we prove the second disjunct. Since $xs_v$ is reflected in $xs_{queue}$, then it must also be the case that $xs_v$ is non-empty, and it has a first element, $x_v$, which is related to the first element of $xs_{queue}$, i.e. $x_{head\_next}$. This allows us to conclude that the returned value ($\nVal{x_{head\_next}}$) is exactly $x_v$, but wrapped in a $\Some$, as we had to prove. 
Finally, we must prove $\isqueue\ q\ xs_v'\ Q_\gname$, where $xs_v'$ is $xs_v$ but with $x_v$ removed. For the existentials, we pick the same values we got from the precondition, wit the exception of $xs_{queue}$ and $x_{head}$. For $xs_{queue}$ we pick the same $xs_{queue}$ we got from the precondition, but with the first element, $x_{head\_next}$ removed. By doing this, $xs_{queue}$ will be reflexed in $xs_v'$. For $x_head$, we pick the new head, which we have obtained that $\loc_{head}$ points to: $x_{head\_next}$. With these choices, we can prove the predicate.



\section{Concurrent Specification}
For the concurrent specification, we will need $\isqueue$ to be duplicable. To achieve this, we shall initially give up on tracking the abstract state of the queue, and instead add a predicate $\Phi$, which we will ensure holds for all elements of the queue. In this way, when dequeueing, we at least know that if we get some value, then $\Phi$ holds of this value. The specification we wish to prove is as follows.
\begin{align*}
  &\exists \isqueue : (\Val \to \Prop) \to \Val \to Qgnames \to \Prop.\\
  &\forall \Phi : \Val \to \Prop.\\
  &\quad\quad \forall v, Q_\gname . \isqueue \ \Phi \ v \ Q_\gname \implies \persistently \isqueue \ \Phi \ v \ Q_\gname\\
  &\land\quad\hoare{\TRUE}{\initialise \TT}{v . \exists Q_\gname, \isqueue\ \Phi \ v \ Q_\gname}\\
  &\land\quad\forall q, v, Q_\gname. \hoare{\isqueue \ \Phi \ q \ Q_\gname \ast \Phi \ v}{\enqueue\ q\ v}{v . \TRUE}\\
  &\land\quad\forall q, Q_\gname. \hoare{\isqueue \ \Phi \ q \ Q_\gname}{\dequeue\ q}{v . v = \None \lor (\exists x_v, v = \Some x_v \ast \Phi \ x_v)}
\end{align*}

\section{Proving the Concurrent Specification}
\subsection[The isqueue predicate]{The $\isqueue$ Predicate}
As we did for the sequential specification, we note here some useful observations
\begin{enumerate}
  \item\label{MSQTL:insights:oldnodes} Nodes in the linked list are never deleted. Hence, the linked list only ever grows.
  \item\label{MSQTL:insights:lag} The tail can lag one node behind Head.
  \item\label{MSQTL:insights:states} At any given time, the queue is in one of four states:
    \begin{enumerate}
      \item\label{MSQTL:insights:state:static} No threads are interacting with the queue (\textbf{Static})
      \item\label{MSQTL:insights:state:enqueue} A thread is enqueueing (\textbf{Enqueue})
      \item\label{MSQTL:insights:state:dequeue} A thread is dequeuing (\textbf{Dequeue})
      \item\label{MSQTL:insights:state:both} A thread is enqueueing and a thread is dequeuing (\textbf{Both})
    \end{enumerate}
\end{enumerate}

Observation \ref{MSQTL:insights:lag} might seem a little surprising, and indeed it stands in contrast to property 5 in \cite{DBLP:conf/podc/MichaelS96}, which states that the tail never lags behind head. I also didn't realise this possibility until a proof attempt using a model that "forgot" old nodes lead to an unprovable case (see section \ref{MSQTL:Discussion:xs_old}). The situation can occur when the queue is empty, and a thread performs an incomplete enqueue; it attaches the new node to the end, but before it can swing the tail to this new node, another thread performs a dequeue, which dequeues this new node, swinging the head to it. Now the tail is lagging a node behind the head.

It is not possible for the tail to point more than one node behind the head, as in order for this to happen, more nodes must be enqueued, but this can't happen before the current enqueue finishes, which will update the tail and bring it up to speed with the head.

Fortunately, this isn't an issue for safety, but a consequence of this possibility is that when modelling the queue, we must remember at least one "old" node (i.e. a dequeued node), as the tail might be pointing to this node. For the sake of simplicity in the model, the choice is made to remember an arbitrary amount of old nodes, which is represented by the list $xs_{old}$.

Observation \ref{MSQTL:insights:states} is a simple consequence of the implementation using two locks.

Since we want $\isqueue$ to be persistent, then we cannot directly state the points-to predicates as we did in the sequential case. However, we will still need all the same resources to be able to prove the specification. The solution is to have an invariant which describes the concrete state of the queue. In the proofs, when we need access to some resource, we shall then access it by opening the invariant. We now present the invariant and explain it afterwards.

\begin{definition}[Two-Lock M\&S-Queue Invariant]\label{MSQTL:spec:invariant}
  \todo{Write it in}
\end{definition}

\todo{explain the invariant: Concrete xs, and abstract xs\_v, with xs\_queue being reflected in xs\_v, tokens (and RA), the four states, quotient points to, isSndLast}


The specification for the two-lock Michael Scott Queue \textit{can} be proven using the queue invariant \ref{MSQTL:spec:invariant}, and the proof outline below will also be using this. However, a simpler (but arguably less intuitive) queue invariant was discovered. This simpler invariant is equivalent to \ref{MSQTL:spec:invariant} and has the benefit of being easier to work with in the mechanised proofs. Thus, in the mechanised proofs, the simpler variant is used. The simpler variant can be found in the appendix \todo{add appendix}.

% \begin{definition}[Simplified Two-Lock M\&S-Queue Invariant]\label{MSQTL:spec:invariant:simple}
%   \todo{Write it in}
% \end{definition}



\subsection{Proof outline}
\todo{prove persistency of isqueue}
The proofs structure for the specifications are largely similar to the sequential counterparts. The major difference is that we don't have access to the resource all the time; we must get it from the invariant, and we also have to keep track of which state we are in.

\subsubsection{initialise}
\todo{do}

\subsubsection{Enqueue}
\todo{do}

\subsubsection{Dequeue}
\todo{do}


\subsubsection{Discussing the need for $xs_{old}$}\label{MSQTL:Discussion:xs_old}
\todo{Update to reflect changes in Coq}
As mentioned in the insights, it is possible for the tail to lag one node behind the head. This insight lead to including the old nodes of the queue in the queue invariant. This addition manifests in the end of the proof of dequeue. When we open the invariant to swing the head to the new node, we get that the entire queue is $xs$. After performing the write, we can then close the invariant with the same $xs$ that we opened the queue to (just written differently to signify that $x_{head}$ is now "old"). Because of this, we can supply the same predicate concerning the $tail$ (the or) that we opened the queue with, since these only mention $xs$, which remains the same.

Had we not used an $xs_{old}$ and essentially just "forgotten" old nodes in the queue, we couldn't have done this. Say that we defined $xs$ as $xs = x_{head} :: xs_{rest}$ instead. Then, once we have to close the invariant, we cannot supply the $xs$, which we got when we opened the invariant. Our only choice (due to the fact that $head$ must point to $x_{n_head}$) is to close the invariant with $xs' = xs_{rest} = x_{n_head} :: xs_{n_rest}''$. However, clearly $xs' \neq xs$, so we cannot supply the same predicate concerning the $tail$ (the or) that we got when opening the invariant, since this predicate talks about $xs$, not $xs'$. Now, if we opened the invariant in the Dequeue case, then we could assert that $last xs = last xs'$, and hence still be able close the invariant. However, if we opened the invariant in the Both case, then we would need to assert that $2last xs = 2last xs'$. This is however not provable, since it might be the case that $xs_{n_rest}''$ is empty, and hence $2last xs'$ is $None$, whereas $2last xs = x_{n_head}$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Conclusion}
\label{ch:conclusion}

\todo{conclude on the problem statement from the introduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain} 
\bibliography{refs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\appendix
\chapter{The Technical Details}

\todo{\dots}

\end{document}

