\documentclass[9pt]{beamer}

\usetheme{Rochester}
\usecolortheme{beaver}

\setbeamersize{text margin left=5mm,text margin right=5mm} 

\usepackage{minted}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{thm-restate}
\usepackage{mathpartir}
\usepackage{epsfig}
\usepackage{stmaryrd}
\usepackage{color}
\usepackage{epstopdf}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage[en-GB]{datetime2}
\DTMlangsetup[en-GB]{showdayofmonth=false}
\usepackage{lipsum}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{pftools}
\usepackage{iris}
\usepackage{heaplang}
\usepackage{tikz}
\usetikzlibrary{calc,shapes.multipart,chains,arrows,scopes,decorations.markings}
\usepackage{xspace}
\usepackage{lineno}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{adjustbox}
\usepackage{csquotes}
\usepackage{natbib}
\usepackage{mathpartir}

\renewcommand*\sfdefault{lmss}
\renewcommand*\ttdefault{txtt}
\definecolor{codebg}{HTML}{f0f0f0}

\newcommand{\isLock}{\operatorname{isLock}}
\newcommand{\locked}{\operatorname{locked}}
\newcommand{\issued}{\operatorname{issued}}
\newcommand{\newLock}{\operatorname{newLock}}
\newcommand{\acquire}{\operatorname{acquire}}
\newcommand{\wait}{\operatorname{wait}}
\newcommand{\release}{\operatorname{release}}
\newcommand{\lockInv}{\operatorname{lockInv}}
\newcommand{\initialise}{\operatorname{initialize}}
\newcommand{\enqueue}{\operatorname{enqueue}}
\newcommand{\dequeue}{\operatorname{dequeue}}
\newcommand{\unwrap}{\operatorname{unwrap}}
\newcommand{\enqdeq}{\operatorname{enqdeq}}
\newcommand{\queueAdd}{\operatorname{queueAdd}}
\newcommand{\parcomp}{\ensuremath{\mathbin{||}}}

\newcommand{\msq}{M\&S Queue}
\newcommand{\tlmsq}{Two-Lock \msq{}}
\newcommand{\lfmsq}{Lock-Free \msq{}}

\newcommand{\isqueue}{\operatorname{isQueue}}
\newcommand{\isqueueseq}{\operatorname{isQueue_{S}}}
\newcommand{\isqueueconc}{\operatorname{isQueue_{C}}}
\newcommand{\TLQueueInvariantConc}{\operatorname{I_{TLC}}}
\newcommand{\TLQueueInvariantConcSimpl}{\operatorname{I^{\prime}_{TLC}}}
\newcommand{\TLQueueInvariantHocap}{\operatorname{I_{TLH}}}
\newcommand{\LFQueueInvariantHocap}{\operatorname{I_{LFH}}}
\newcommand{\SeqQgnames}{SeqQgnames}
\newcommand{\ConcQgnames}{ConcQgnames}
\newcommand{\Qgnames}{Qgnames}
\newcommand{\QueueAddInvariant}{I_{QA}}

\newcommand{\vq}{v_q}
\newcommand{\xsc}{xs}
\newcommand{\xsqueue}{xs_{\mathrm{queue}}}
\newcommand{\xsold}{xs_{\mathrm{old}}}

\newcommand{\isLLchain}{\operatorname{isLL\_chain}}
\newcommand{\isLL}{\operatorname{isLL}}
\newcommand{\AllP}{\operatorname{All}}
\newcommand{\projval}{\operatorname{projVal}}
\newcommand{\wrapsome}{\operatorname{wrapSome}}
\newcommand{\isFirst}{\operatorname{isFirst}}
\newcommand{\isLast}{\operatorname{isLast}}
\newcommand{\isSndLast}{\operatorname{isSndLast}}
\newcommand{\projqgnamesseq}{\operatorname{projQgnames_{S}}}
\newcommand{\projqgnamesconc}{\operatorname{projQgnames_{C}}}

\newcommand{\locin}{\loc_{\mathrm{in}}}
\newcommand{\locinM}[1]{\loc_{#1\_\mathrm{in}}}
\newcommand{\locout}{\loc_{\mathrm{out}}}
\newcommand{\locoutM}[1]{\loc_{#1\_\mathrm{out}}}

\newcommand{\locN}[1]{\loc_{\mathrm{#1}}}
\newcommand{\lochead}{\locN{head}}
\newcommand{\loctail}{\locN{tail}}
\newcommand{\locqueue}{\locN{queue}}

\newcommand{\nodeval}{\valB}
\newcommand{\nodevalM}[1]{\nodeval_{#1}}

\newcommand{\nIn}[1]{\operatorname{in}(#1)}
\newcommand{\nVal}[1]{\operatorname{val}(#1)}
\newcommand{\nOut}[1]{\operatorname{out}(#1)}

\newcommand{\node}{x}
\newcommand{\nodeM}[1]{\node_{#1}}
\newcommand{\nodeN}[1]{\node_{\mathrm{#1}}}
\newcommand{\nodehead}{\nodeN{head}}
\newcommand{\nodetail}{\nodeN{tail}}
\newcommand{\nodelast}{\nodeN{last}}
\newcommand{\nodenew}{\nodeN{new}}
\newcommand{\nodeheadnext}{\nodeN{head\_next}}
\newcommand{\nodetailnext}{\nodeN{tail\_next}}
\newcommand{\nodenewtail}{\nodeN{newtail}}

\newcommand{\absvalue}{\val}
\newcommand{\absvalueList}{xs_v}

\newcommand{\Hlock}{h_{\mathrm{lock}}}
\newcommand{\Tlock}{t_{\mathrm{lock}}}
\newcommand{\Hlockvar}{H\_lock}
\newcommand{\Tlockvar}{T\_lock}

\newcommand{\prophval}{\val_p}

\newcommand{\StaticState}{\textbf{Static}\xspace}
\newcommand{\EnqueueState}{\textbf{Enqueue}\xspace}
\newcommand{\DequeueState}{\textbf{Dequeue}\xspace}
\newcommand{\BothState}{\textbf{Both}\xspace}

\newcommand{\Qg}{G}
\newcommand{\Qgseq}{G_{S}}
\newcommand{\Qgconc}{G_{C}}
\newcommand{\Qghocap}{G_{H}}
\newcommand{\QAg}{Ga}

\newcommand{\ghlock}{\gname_{\mathrm{Hlock}}}
\newcommand{\gtlock}{\gname_{\mathrm{Tlock}}}
\newcommand{\gabst}{\gname_{\mathrm{Abst}}}
\newcommand{\ghead}{\gname_{\mathrm{Head}}}
\newcommand{\gtail}{\gname_{\mathrm{Tail}}}
\newcommand{\glast}{\gname_{\mathrm{Last}}}

\newcommand{\Token}[1]{\operatorname{Token}(#1)}
\newcommand{\TokE}[1]{\operatorname{TokE} ~ #1}
\newcommand{\TokEQg}{\TokE{\Qg}}
\newcommand{\TokNE}[1]{\operatorname{TokNE} ~ #1}
\newcommand{\TokNEQg}{\TokNE{\Qg}}
\newcommand{\TokD}[1]{\operatorname{TokD} ~ #1}
\newcommand{\TokDQg}{\TokD{\Qg}}
\newcommand{\TokND}[1]{\operatorname{TokND} ~ #1}
\newcommand{\TokNDQg}{\TokND{\Qg}}
\newcommand{\TokBefore}[1]{\operatorname{TokBefore} ~ #1}
\newcommand{\TokBeforeQg}{\TokBefore{\Qg}}
\newcommand{\TokAfter}[1]{\operatorname{TokAfter} ~ #1}
\newcommand{\TokAfterQg}{\TokAfter{\Qg}}
\newcommand{\TokUpdated}[1]{\operatorname{TokUpdated} ~ #1}
\newcommand{\TokUpdatedQg}{\TokUpdated{\Qg}}
\newcommand{\TokDo}[1]{\operatorname{TokD1} ~ #1}
\newcommand{\TokDoQAg}{\TokDo{\QAg}}
\newcommand{\TokDt}[1]{\operatorname{TokD2} ~ #1}
\newcommand{\TokDtQAg}{\TokDt{\QAg}}
\newcommand{\TokA}[1]{\operatorname{TokA} ~ #1}
\newcommand{\TokAQAg}{\TokA{\QAg}}
\newcommand{\TokB}[1]{\operatorname{TokB} ~ #1}
\newcommand{\TokBQAg}{\TokB{\QAg}}

\newcommand\catenate{\mathbin{\text{\ttfamily\upshape ++}}}

\newcommand{\BB}{\ensuremath{\mathbb{B}}}
\newcommand{\Cc}{\ensuremath{\mathbf{C}}}
\newcommand{\El}{\ensuremath{\mathcal{E}}}
\newcommand{\Sl}{\ensuremath{\mathcal{S}}}
\newcommand{\Ul}{\ensuremath{\mathcal{U}}}
\newcommand{\Dl}{\ensuremath{\mathcal{D}}}
\newcommand{\Fl}{\ensuremath{\mathcal{F}}}
\newcommand{\Pl}{\ensuremath{\mathcal{P}}}
\newcommand{\Tl}{\ensuremath{\mathcal{T}}}
\newcommand{\CC}{\ensuremath{\mathbb{C}}}
\newcommand{\KK}{\ensuremath{\mathbb{K}}}
\newcommand{\PP}{\ensuremath{\mathbb{P}}}
\newcommand{\VV}{\ensuremath{\mathbb{V}}}
\newcommand{\UU}{\ensuremath{\mathbb{U}}}
\newcommand{\DD}{\ensuremath{\mathbb{D}}}
\newcommand{\Ml}{\ensuremath{\mathcal{M}}}
\newcommand{\Vl}{\ensuremath{\mathcal{V}}}
\newcommand{\Il}{\ensuremath{\mathcal{I}}}
\newcommand{\Cl}{\ensuremath{\mathcal{C}}}
\newcommand{\Bl}{\ensuremath{\mathcal{B}}}
\newcommand{\Al}{\ensuremath{\mathcal{A}}}
\newcommand{\Gl}{\ensuremath{\mathcal{G}}}
\newcommand{\Nl}{\ensuremath{\mathcal{N}}}
\newcommand{\AAA}{\ensuremath{\mathbb{A}}}
\newcommand{\EE}{\ensuremath{\mathbb{E}}}

\newcommand{\isNode}[1]{\nIn{#1} \mapsto^{\persistently} (\nVal{#1}, \nOut{#1})}

\newcommand{\abstractstatefrac}[3]{#1 \Mapsto\kern-0.5ex\tfrac{1}{#2} #3}
\newcommand{\abstractstate}[3]{#1 \Mapsto^{#2}_{\circ} #3}
\newcommand{\abstractstatefullfrag}[2]{#1 \Mapsto_{\circ} #2}
\newcommand{\abstractstateauth}[2]{#1 \Mapsto_{\bullet} #2}

\newcommand{\reach}[2]{#1 \leadsto #2}
\newcommand{\ar}[2]{#1 \dashrightarrow #2}
\newcommand{\ap}[2]{#1 \rightarrowtail #2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Specifications

% ------ Sequential Specification ------
% Initialise

\newcommand{\seqspecinitHTGen}[2]{\hoare{\TRUE}{\initialise \ \TT}{#1 . \Exists #2. \isqueueseq(#1, [], #2)}}

\newcommand{\seqspecinitGen}[2]{\seqspecinitHTGen{#1}{#2}}

\newcommand{\seqspecinit}{\seqspecinitGen{\vq}{\Qg}}

% Enqueue
\newcommand{\seqspecenqHT}[4]{\hoare{\isqueueseq(#1, #3, #4)}{\enqueue \ #1 \ #2}{\valB . \isqueueseq(#1, (#2 :: #3), #4)}}

\newcommand{\seqspecenqGen}[4]{\All #1, #2, #3, #4. \seqspecenqHT{#1}{#2}{#3}{#4}}

\newcommand{\seqspecenq}{\seqspecenqGen{\vq}{\absvalue}{\absvalueList}{\Qg}}

% Dequeue
\newcommand{\seqspecdeqHT}[3]{\hoareV[t]{\isqueueseq(#1, #2, #3)}{\dequeue \ #1}{\nodeval . \begin{array}{l}(#2 = [] \star{} \nodeval = \None \star{} \isqueueseq(#1, #2, #3)) \lor{}\\ (\Exists \absvalue, #2' . #2 = #2' \catenate [\absvalue] \star{} \nodeval = \Some \absvalue \star{} \isqueueseq(#1, #2', #3)) \end{array}}}

\newcommand{\seqspecdeqGen}[3]{\All #1, #2, #3. \seqspecdeqHT{#1}{#2}{#3}}

\newcommand{\seqspecdeq}{\seqspecdeqGen{\vq}{\absvalueList}{\Qg}}


% ------ Concurrent Specification ------
% Initialise
\newcommand{\concspecinitHTGen}[3]{\hoare{\TRUE}{\initialise \ \TT}{#2 . \Exists #3. \isqueueconc(#1, #2, #3)}}

\newcommand{\concspecinitGen}[3]{\concspecinitHTGen{#1}{#2}{#3}}

\newcommand{\concspecinit}[1]{\concspecinitGen{#1}{\vq}{\Qg}}

% Enqueue
\newcommand{\concspecenqHT}[4]{\hoare{\isqueueconc(#1, #2, #4) \star{} #1(#3)}{\enqueue \ #2 \ #3}{\valB . \TRUE}}

\newcommand{\concspecenqGen}[4]{\All #2, #3, #4. \concspecenqHT{#1}{#2}{#3}{#4}}

\newcommand{\concspecenq}[1]{\concspecenqGen{#1}{\vq}{\absvalue}{\Qg}}

% Dequeue
\newcommand{\concspecdeqHT}[3]{\hoare{\isqueueconc(#1, #2, #3)}{\dequeue \ #2}{\nodeval . \nodeval = \None \lor{} (\Exists \absvalue . \nodeval = \Some \absvalue \star{} #1(\absvalue))}}

\newcommand{\concspecdeqGen}[3]{\All #2, #3. \concspecdeqHT{#1}{#2}{#3}}

\newcommand{\concspecdeq}[1]{\concspecdeqGen{#1}{\vq}{\Qg}}


% ------ HOCAP-style Specification ------
% Initialise
\newcommand{\hocapspecinitHTGen}[2]{\hoare{\TRUE}{\initialise \ \TT}{#1 . \Exists #2 . \isqueue(#1, #2) \star{} \abstractstatefullfrag{#2.\gabst}{[]}}}

\newcommand{\hocapspecinitGen}[2]{\hocapspecinitHTGen{#1}{#2}}

\newcommand{\hocapspecinit}{\hocapspecinitGen{\vq}{\Qg}}

% Enqueue
\newcommand{\hocapspecenqVS}[5]{\abstractstateauth{#2.\gabst}{#5} \star{} #3 \vs[\mask\setminus\Nl.i^\uparrow] \later \abstractstateauth{#2.\gabst}{(#1 :: #5)} \star{} #4}

\newcommand{\hocapspecenqHT}[5]{\hoare{\isqueue(#1, #3) \star{} #4}{\enqueue \ #1 \ #2}{\valB . #5}}

\newcommand{\hocapspecenqGen}[6]{\All #1, #2, #3, #4, #5.
\begin{array}[t]{l}
\left(\All #6 . \hocapspecenqVS{#2}{#3}{#4}{#5}{#6} \right)
\wand\\
\hocapspecenqHT{#1}{#2}{#3}{#4}{#5}
\end{array}}

\newcommand{\hocapspecenq}{\hocapspecenqGen{\vq}{\absvalue}{\Qg}{P}{Q}{\absvalueList}}

% Dequeue
\newcommand{\hocapspecdeqVSGen}[6]{
  \abstractstateauth{#1.\gabst}{#4} \star{} #2 \vs[\mask\setminus\Nl.i^\uparrow] \later
  \left(
    \begin{array}{l}
      (#4 = [] \star{} \abstractstateauth{#1.\gabst}{#4} \star{} #3(\None))\\
      \lor{}
      \left(
        \begin{array}{l}
          \Exists #5, #6 . #4 = #6 \catenate [#5] \star{}\\
          \abstractstateauth{#1.\gabst}{#6} \star{} #3(\Some{#5})
        \end{array}
        \right)
    \end{array}
  \right)
}
\newcommand{\hocapspecdeqVS}[4]{\hocapspecdeqVSGen{#1}{#2}{#3}{#4}{\absvalue}{#4'}}

\newcommand{\hocapspecdeqHT}[4]{\hoare{\isqueue(#1, #2) \star{} #3}{\dequeue \ #1}{\nodeval . #4(\nodeval)}}

\newcommand{\hocapspecdeqGen}[5]{\begin{array}[t]{l}
  \All #1, #2, #3, #4.\\
  \begin{array}[t]{l}
  \quad\left(\All #5 . \hocapspecdeqVS{#2}{#3}{#4}{#5} \right) \wand\\
  \quad\hocapspecdeqHT{#1}{#2}{#3}{#4}
  \end{array}
\end{array}}

\newcommand{\hocapspecdeq}{\hocapspecdeqGen{\vq}{\Qg}{P}{Q}{\absvalueList}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Inferences Rules
% From https://github.com/logsem/iris-lecture-notes

%% Macros for constructing iterated inference rules with similar labels
% Constructs a rule with name #2, label #3 (with postfix #1; default empty),
% hypotheses #4 and conclusion #5
% ex: \rulegenhref[-app]{$\ast$-weak}{star-weak}{ }{P_1 \ast P_2 \proves P_1}
\newcommand{\rulegenhref}[5][]{\inferhref{#2}{#3#1}{#4}{#5}}
% Variant for constructing bi-inference rules
\newcommand{\rulegenhrefb}[5][]{\inferhrefB{#2}{#3#1}{#4}{#5}}
% Variant where name and label coincide
\newcommand{\rulegen}[4][]{\rulegenhref[#1]{#2}{#2}{#3}{#4}}
% Variant of bi-inference where name and label coincide
\newcommand{\rulegenb}[4][]{\rulegenhrefb[#1]{#2}{#2}{#3}{#4}}

\newcommand{\logicstarweakrule}[1][]
{ \rulegenhref[#1]{$\ast$-weak}{star-weak}
  { }
  {P_1 \ast P_2 \proves P_1}}

\newcommand{\logicstarassocrule}[1][]
{ \rulegenhref[#1]{$\ast$-assoc}{star-assoc}
  { }
  {P_1 \ast (P_2 \ast P_3) \provesIff (P_1 \ast P_2) \ast P_3}}

\newcommand{\logicstarcommrule}[1][]
{ \rulegenhref[#1]{$\ast$-comm}{star-comm}
  { }
  {P_1 \ast P_2 \provesIff P_2 \ast P_1}}

\newcommand{\logicstarintrorule}[1][]
{ \rulegenhref[#1]{$\ast$I}{star-I}
  {P_1 \proves Q_1 \and P_2 \proves Q_2 }
  {P_1 \ast P_2 \proves Q_1 \ast Q_2 }}

\newcommand{\logicwandintrorule}[1][]
{ \rulegenhref[#1]{$\wand$I}{wand-I}
  {R \ast \prop \proves \propB}
  {R \proves \prop \wand \propB}}

\newcommand{\logicwandelimrule}[1][]
{ \rulegenhref[#1]{$\wand$E}{wand-E}
  {R_1 \proves \prop \wand \propB \and R_2 \proves \prop}
  {R_1 \ast R_2 \proves \propB}}

\newcommand{\persduprule}[1][]
{ \rulegen[#1]{persistently-dup}
  {}{\persistently P \provesIff \persistently P \ast P}}

\newcommand{\persintrorule}[1][]
{ \rulegen[#1]{persistently-intro}
  {\persistently P \proves Q}{\persistently P \proves \persistently Q}}

\newcommand{\perskeeprule}[1][]
{ \rulegen[#1]{persistently-keep}
  {P \proves \persistently Q}{P \proves \persistently Q \ast P}}

\newcommand{\pershtrule}[1][]
{ \rulegen[#1]{persistently-Ht}{}{\hoare{P}{e}{\Phi} \provesIff \persistently \hoare{P}{e}{\Phi}}}

\newcommand{\lobrule}[1][]
{ \rulegenhref[#1]{L{\"o}b}{Loeb}
  {Q \land \later\prop \proves \prop}
  {Q \proves \prop}}

\newcommand{\latermonorule}[1][]
{ \rulegenhref[#1]{later-mono}{Later-Mono}
  {Q \proves \prop}
  {\later Q \proves \later\prop}}

\newcommand{\laterweakrule}[1][]
{ \rulegenhref[#1]{later-weak}{Later-weak}
  {Q \proves \prop}
  {Q \proves \later{\prop}}}

\newcommand{\htframe}[1][]
{ \rulegen[#1]{Ht-frame}
  {S \proves \hoare{P}{e}{v.Q}}
  {S \proves \hoare{P \ast R}{e}{v.Q \ast R}}}

\newcommand{\htret}[1][]
{ \rulegen[#1]{Ht-ret}
  {w \text{ is a value }}
  {S \proves \hoare{\TRUE}{\valB}{v. v = \valB}}}

\newcommand{\htbind}[1][]
{\rulegen[#1]{Ht-bind}
  { \text{$\lctx$ is an eval. context} \and
    S \proves \hoare{\prop}{\expr}{\Ret\val. \propB} \and
    S \proves \All \val. \hoare{\propB}{\lctx[\val]}{\Ret\valB.\propC}}
  { S \proves \hoare{\prop}{\lctx[\expr]}{\Ret\valB.\propC}}}

\newcommand{\htloadgen}[2][]
{ \rulegen[#1]{Ht-load}
  { }
  { S \proves \hoare{#2 \ell \pointsto u}{\deref \ell}{v . v = u \land \ell \pointsto u}}}

\newcommand{\htloadtemp}[1][]
{ \htloadgen[-temp#1]{ }}

\newcommand{\htalloc}[1][]
{ \rulegen[#1]{Ht-alloc}
  { }
  { S \proves \hoare{\TRUE}{\Ref(u)}{v . \Exists \ell . v = \ell\land \ell \pointsto u}}}

\newcommand{\htstoregen}[2][]
{ \rulegen[#1]{Ht-store}
  { }
  { S \proves \hoare{#2 \ell \pointsto -}{\ell \gets w }{v . v = \TT \land \ell \pointsto w}}}

\newcommand{\htstoretemp}[1][]
{\htstoregen[-temp#1]{ }}


%% Generic command for constructing variations of the consequence rule
\newcommand{\htcsq}[1][]
{ \rulegen[#1]{Ht-csq}
  { S \text{ persistent } \and
  S \proves \prop \Rightarrow{} \prop' \and
  S \proves \hoare{\prop'}{\expr}{\Ret\val.\propB'} \and
  S \proves \All u. \propB'[u/v] \Rightarrow{} \propB[u/v]}
  {S \proves \hoare{\prop}{\expr}{\Ret\val.\propB}}}

\newcommand{\htcsqvsrule}[1][]
{ \rulegen[#1]{Ht-csq-vs}
  { S \proves \prop \vs \prop' \and
    S \proves \hoare{\prop'}{\expr}{\Ret\val.\propB'} \and
    S \proves \All u. \propB'[u/v] \vs \propB[u/v]}
  {S \proves \hoare{\prop}{\expr}{\Ret\val.\propB}}}

\newcommand{\htbetagen}[4][]
{ \rulegen[#1]{Ht-beta#1}
  {S \proves \hoare{P}{e\left[v/x\right]}{u.Q}[#3]}
  {S \proves \hoare{#2 P}{(\lambda x . e) v}{u.Q}[#3]}}

\newcommand{\htbeta}[1][]{\htbetagen[#1]{ }{ }}

\newcommand{\htbetalater}[1][]{\htbetagen[-later#1]{\later}{}}

\newcommand{\htloadlaterrule}[1][]{\htloadgen[#1]{\later}}

\newcommand{\htstorelaterrule}[1][]{\htstoregen[#1]{\later}}

\newcommand{\Htpar}[1][]
{ \rulegen[#1]{Ht-par}
    {S \proves \hoare{P_1}{e_1}{v.Q_1} \and S \proves \hoare{P_2}{e_2}{v.Q_2}}
    {S \proves \hoare{P_1 \ast P_2}{e_1 \parcomp e_2}{v.\Exists v_1 v_2.v = (v_1,v_2) \ast Q_1[v_1/v] \ast Q_2[v_2/v]}}}

\newcommand{\fpurule}[1][]
{ \rulegen[#1]{frame-preserving-update}
  {}{a \mupd b \iff \forall x \in \Ml, a \cdot x \in \Vl \implies b \cdot x \in \Vl.}}

\newcommand{\updmonorule}[1][]
{\rulegen[#1]{upd-mono}
  {P \proves Q}
  {\pvs P \proves \pvs Q}}

\newcommand{\updintrorule}[1][]
{\rulegen[#1]{upd-intro}{ }
  {P \proves \pvs P}}

\newcommand{\updidemprule}[1][]
{\rulegen[#1]{upd-idemp}
  { }
  {\pvs \pvs P \proves \pvs P}}

\newcommand{\updframerule}[1][]
{\rulegen[#1]{upd-frame}
  { }
  {P \ast \pvs Q \proves \pvs (P \ast Q)}}

\newcommand{\ghostallocrule}[1][]
{\rulegen[#1]{Ghost-alloc}
  {a \in \Vl}
  {\TRUE \proves \pvs \Exists \gamma . \ownGhost{\gamma}{a}}}

\newcommand{\ghostupdaterule}[1][]
{\rulegen[#1]{Ghost-update}
  {a \mupd b}
  { \ownGhost{\gamma}{a} \proves \pvs \ownGhost{\gamma}{b}}}

\newcommand{\ownoprule}[1][]
{ \rulegen[#1]{Own-op}
  { }
  {\ownGhost{\gamma}{a} \ast \ownGhost{\gamma}{b} \provesIff \ownGhost{\gamma}{a \cdot b}}}

\newcommand{\ownvalidrule}[1][]
{ \rulegen[#1]{Own-valid}
  { }
  {\ownGhost{\gamma}{a} \proves a \in \Vl}}

\newcommand{\invalloc}
{ \rulegen[]{Inv-alloc}
  {}
  {\later P \proves \pvs[\emptyset] \knowInv{\Nl}{P}}}

\newcommand{\wpinvopen}[1][]
{ \rulegen[#1]{wp-inv-open-namespace}
  {e \text{ is an atomic expression } \and \Nl^\uparrow \subseteq \mask}
  {\knowInv{\Nl}{P} \ast \left(\later P \wand \wpre{e}[\mask\setminus\Nl^\uparrow]{v.\later P \ast \Phi(v)}\right)
    \proves{}
    \wpre{e}[\mask]{\Phi}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}


\addtobeamertemplate{navigation symbols}{}{%
    \usebeamerfont{footline}%
    \usebeamercolor[fg]{footline}%
    \hspace{1em}%
    \insertframenumber/\inserttotalframenumber
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Master's Thesis Exam\\
Verification of the Blocking and Non-Blocking Michael-Scott Queue Algorithms}
\author{
  Mathias Pedersen, 201808137 \texorpdfstring{\\}{with}
  {\small Advisor: Amin Timany}
}
\institute{Aarhus University}
\date{\today}
\titlegraphic { 
\begin{tikzpicture}[overlay,remember picture]
\node[right=0.3cm] at (current page.210){
    \includegraphics[scale=0.7]{../thesis/logo.eps}
};
\end{tikzpicture}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\todo}[1]{{\color[rgb]{.5,0,0}\textbf{$\blacktriangleright$#1$\blacktriangleleft$}}}

\begin{document}

\frame{\titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Overview of the Project and Contributions}
  \todo{create slide}
  % - Motivation
  % - Take contributions from list in introduction
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Outline
\begin{frame}{Outline}
  \tableofcontents
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Queue Specifications}

%=====================================================================
\begin{frame}{Specifications for Queues}
  \begin{block}{Assumptions on Queues}
    \begin{itemize}
      \item Queues consists of $\initialise$, $\enqueue$, and $\dequeue$
      \item $\initialise$ creates an empty queue: $[]$
      \item $\enqueue$ adds a value, $\absvalue$, to the beginning of the queue $\absvalueList$: $\absvalue :: \absvalueList$
      \item $\dequeue$ depends on whether queue is empty:
        \begin{itemize}
          \item If non-empty, $\absvalueList \catenate \absvalue$, remove $\absvalue$ and return $\Some \absvalue$
          \item If empty, $[]$, return $\None$
        \end{itemize}
    \end{itemize}
  \end{block}
  \begin{block}{Nature of Specifications}
    \begin{itemize}
      \item Specifications written in Iris, a higher order CSL
      \item Expressed in terms of \textit{Hoare triples}: $\hoare{P}{e}{v. \Phi ~ v}$
      \item Hoare triples prove partial correctness of programs, $e$
      \item In particular: safety
      \item Idea: clients can use Hoare triples to prove results about their own code
    \end{itemize}
  \end{block}
\end{frame}

%=====================================================================
\begin{frame}{Sequential Specification}
  \begin{definition}[Sequential Specification]\label{QueueSpecs:spec:seq}
    \begin{align*}
      &\Exists \isqueueseq : \Val \to \List ~ \Val \to \SeqQgnames \to \Prop.\\
      &\quad\quad\seqspecinit\\
      &\land{}\quad\seqspecenq\\
      &\land{}\quad\seqspecdeq
    \end{align*}
  \end{definition}
  \begin{itemize}
    \item The proposition $\isqueueseq(\vq, \absvalueList, \Qg)$, states that value $\vq$ represents the queue, which contains elements $\absvalueList$
    \item $G \in \SeqQgnames{}$ is a collection of ghost names (depends on specific queue)
    \item Specification consists of three Hoare triples -- one for each queue function
    \item Important: $\isqueueseq$ not required to be persistent!
  \end{itemize}
\end{frame}

%=====================================================================
\begin{frame}{Concurrent Specification}
  % - Support for concurrent through persistency of queue predicate
  \begin{definition}[Concurrent Specification]\label{QueueSpecs:spec:conc}
    \begin{align*}
      &\Exists \isqueueconc : (\Val \to \Prop) \to \Val \to \ConcQgnames \to \Prop.\\
      &\All \Psi : \Val \to \Prop.\\
      &\quad\quad \All \vq, \Qg . \isqueueconc(\Psi, \vq, \Qg) \implies \persistently \isqueueconc(\Psi, \vq, \Qg)\\
      &\land{}\quad\concspecinit{\Psi}\\
      &\land{}\quad\concspecenq{\Psi}\\
      &\land{}\quad\concspecdeq{\Psi}
    \end{align*}
  \end{definition}
\end{frame}


%=====================================================================
\begin{frame}{HOCAP-style Specification - Abstract State RA}
  \begin{itemize}
    \item \todo{Introduce Auth and Frag predicates for tracking abstract state}
    \item \todo{Show Resource Algebra}
  \end{itemize}
  \begin{block}{Lemmas on the Abstract State RA}
    \begin{align*}
      &\proves \pvs \Exists \gname . \abstractstateauth{\gname}{\absvalueList} \star{} \abstractstatefullfrag{\gname}{\absvalueList} & \text{(Abstract State Alloc)}\\[0.8ex]
      &\abstractstateauth{\gname}{\absvalueList'} \star{}
      \abstractstatefullfrag{\gname}{\absvalueList} \proves
      \absvalueList = \absvalueList' & \text{(Abstract State Agree)}\\[0.8ex]
      &\abstractstateauth{\gname}{\absvalueList'} \star{}
      \abstractstatefullfrag{\gname}{\absvalueList} \vs
      \abstractstateauth{\gname}{\absvalueList''} \star{}
      \abstractstatefullfrag{\gname}{\absvalueList''} & \text{(Abstract State Update)}
    \end{align*}
  \end{block}
\end{frame}

%=====================================================================
\begin{frame}{HOCAP-style Specification}
  \begin{definition}[HOCAP Specification]\label{QueueSpecs:spec:hocap}
    \begin{align*}
      &\Exists \isqueue : \Val \to \Qgnames \to \Prop.\\
      &\quad\quad \All \vq, \Qg . \isqueue(\vq, \Qg) \implies \persistently \isqueue(\vq, \Qg)\\
      &\land{}\quad\hocapspecinit\\
      &\land{}\quad\hocapspecenq\\
      &\land{}\quad\hocapspecdeq
    \end{align*}
  \end{definition}
\end{frame}

%=====================================================================
\begin{frame}[containsverbatim]{Queue Client - A PoC Client}
  \begin{itemize}
    \item Idea: a minimal client complex enough to require HOCAP specification
    \item Concurrent, so sequential specification insufficient
    \item Relies on dequeues not returning $\None$, so concurrent specification insufficient
    \item HOCAP specification supports consistency and allows us to track queue contents, allowing us to exclude cases where dequeue returns $\None$ 
  \end{itemize}
  \begin{minted}[linenos=true, escapeinside=||, mathescape=true, bgcolor=codebg, frame=lines]{ocaml}
  |$\label{UNW:def}$|  |$ \unwrap \ w \eqdef \langkw{match}\spac w \spac\langkw{with}\spac \None \Ra \TT \ \TT \mid \Some v \Ra v \spac\langkw{end} $|
  
  |$\label{EDQ:def}$|  |$ \enqdeq \ \vq \ c \eqdef \enqueue \ \vq \ c; \unwrap (\dequeue \ \vq)$|
  
  |$\label{QAD:def}$|  |$ \queueAdd \ a \ b \eqdef $|
  |$\label{QAD:que}$|    |$ \Let \vq = \initialise \ \TT in $|
  |$\label{QAD:spw}$|    |$ \Let p = (\enqdeq \ \vq \ a) \parcomp (\enqdeq \ \vq \ b) in $|
  |$\label{QAD:add}$|    |$ \Fst p + \Snd p $|
  \end{minted}
\end{frame}

%=====================================================================
\begin{frame}[containsverbatim]{Queue Client - A PoC Client (continued)}
  
  \begin{lemma}[QueueAdd Specification]\label{QueueSpecs:spec:queueadd}
    \begin{equation*}
      \All a, b \in \mathbb{Z} . \hoare{\TRUE}{\queueAdd \ a \ b}{v . v = a + b}
    \end{equation*}
  \end{lemma}

  \begin{itemize}
    \item Proof idea: Create invariant capturing possible states of queue contents
    \item Tokens are used to reason about which state we are in
  \end{itemize}
  
  \begin{definition}[Invariant for QueueAdd]\label{QueueSpecs:queueadd:invariant}
    \begin{align*}
      \QueueAddInvariant(\Qg, \QAg, a, b) \eqdef~
      &\abstractstatefullfrag{\Qg.\gabst}{[]}~\star~\TokDoQAg~\star~\TokDtQAg~\lor\\
      &\abstractstatefullfrag{\Qg.\gabst}{[a]}~\star~\TokAQAg~\star~(\TokDoQAg~\lor~\TokDtQAg)~\lor\\
      &\abstractstatefullfrag{\Qg.\gabst}{[b]}~\star~\TokBQAg~\star~(\TokDoQAg~\lor~\TokDtQAg)~\lor\\
      &\abstractstatefullfrag{\Qg.\gabst}{[a; b]}~\star~\TokAQAg~\star~\TokBQAg~\lor\\
      &\abstractstatefullfrag{\Qg.\gabst}{[b; a]}~\star~\TokBQAg~\star~\TokAQAg~\lor
    \end{align*}
  \end{definition}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The Two-Lock Michael-Scott Queue}

%=====================================================================
\begin{frame}{Implementation: $\initialise$}
  \todo{create slide}
  % - Show code
  % - Show figure
\end{frame}

%=====================================================================
\begin{frame}{Implementation: $\enqueue$}
  \todo{create slide}
  % - Show code
  % - Show figure
\end{frame}

%=====================================================================
\begin{frame}{Implementation: $\dequeue$}
  \todo{create slide}
  % - Show code
  % - Show figure
\end{frame}

%=====================================================================
\begin{frame}{Observations on Behaviour of the \tlmsq}
  \todo{create slide}
  % - Include main observations from section on observations
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Proving that the Two-Lock Michael-Scott Queue Satisfies the HOCAP-style Specification}

%=====================================================================
\begin{frame}{Invariant}
  \todo{create slide}
  % - Motivate the need for invariant
  % + Queue Predicate must be persistent (according to spec)
  % + The queue relies on non-persistent resources
  % + Solution is to identify an invariant for the queue, which describes the resources
  % + Invariants are persistent
  % - Show invariant
\end{frame}

%=====================================================================
\begin{frame}{The isLL Predicate}
  \todo{create slide}
  % - Idea, capture the linked list structure with Iris points-to predicates
  % - Show a figure (from an implementation slide)
  % - Show definition
  % - Show example from report
\end{frame}

%=====================================================================
\begin{frame}{Queue Predicate}
  \todo{create slide}
  % - Remind that the HOCAP-style spec requires the existence of some queue predicate
  % - Show queue predicate
  % - Queue predicate is persistent
  % - Proving that TLMSQ satisfies HOCAP spec then consists of proving the Hoare triples for initialise, enqueue, and dequeue.
  % - We here focus on initialise and \todo{enqueue xor dequeue}
\end{frame}

%=====================================================================
\begin{frame}{Proof of Initialise}
  \todo{create slide}
  % Start with the code. Add lines with {...} in between lines of code to signify which propositions hold during execution. Copy propositions from proof outlines in report.
\end{frame}

%=====================================================================
\begin{frame}{Proof of \todo{$\enqueue$ xor $\dequeue$} }
  \todo{create slide}
  % Start with the code. Add lines with {...} in between lines of code to signify which propositions hold during execution. Copy propositions from proof outlines in report.
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The Lock-Free Michael-Scott Queue}

%=====================================================================
\begin{frame}{Implementation: $\initialise$}
  \todo{create slide}
  % - Show code
  % - Show figure (mention differences with TLMSQ)
\end{frame}

%=====================================================================
\begin{frame}{Implementation: $\enqueue$}
  \todo{create slide}
  % - Show code
  % - Show figure (mention differences with TLMSQ)
\end{frame}

%=====================================================================
\begin{frame}{Implementation: $\dequeue$}
  \todo{create slide}
  % - Show code
  % - Show figure (mention differences with TLMSQ)
\end{frame}

%=====================================================================
\begin{frame}{Prophecies}
  \todo{create slide}
  % - consistency checks, linearisation points, and prophecies
  % + need prophecy in proof of adherence to HOCAP
  % + Linearisation point can depend on future computation
  % + Reason for consistency checks: ABA problem in original
  % + can remove consistency checks due to garbage collected language
\end{frame}

%=====================================================================
\begin{frame}[containsverbatim]{The Lock-and-CC-Free Michael-Scott Queue}
  \todo{format}
  \begin{figure}
  \begin{minted}[escapeinside=||, mathescape=true, bgcolor=codebg, frame=lines, fontsize=\scriptsize]{ocaml}
  |$\label{LFI:fun}$|  |$ \initialise \eqdef $|
  |$\label{LFI:nod}$|    |$ \Let node = \Ref(\None, \Ref(\None)) in $|
  |$\label{LFI:que}$|    |$ \Ref(\Ref(node), \Ref(node)) $|

  |$\label{LFE:fun}$|  |$ \enqueue \ Q \ value \eqdef $|
  |$\label{LFE:nod}$|    |$ \Let node = \Ref(\Some value, \Ref(\None)) in $|
  |$\label{LFE:lop}$|    |$ (\Rec {loop} \_ = $|
  |$\label{LFE:tal}$|      |$ \Let tail = \deref (\Snd (\deref Q)) in$|
  |$\label{LFE:nex}$|      |$ \Let next = \deref (\Snd (\deref tail)) in $|
  |$\label{LFE:nen}$|      |$ \If next = \None then $|
  |$\label{LFE:add}$|        |$ \If \CAS \ (\Snd (\deref tail)) \ next \ node then $|
  |$\label{LFE:sts}$|          |$ \CAS \ (\Snd (\deref Q)) \ tail \ node $|
  |$\label{LFE:re1}$|        |$ \Else loop \ \TT $|
  |$\label{LFE:stl}$|      |$ \Else \CAS \ (\Snd (\deref Q)) \ tail \ next; loop \ \TT $|
  |$\label{LFE:app}$|    |$ ) \ \TT $|

  |$\label{LFD:fun}$|  |$ \dequeue \ Q \eqdef $|
  |$\label{LFD:lop}$|    |$ (\Rec {loop} \_ = $|
  |$\label{LFD:hed}$|      |$ \Let head = \deref (\Fst (\deref Q)) in $|
  |$\label{LFD:tal}$|      |$ \Let tail = \deref (\Snd (\deref Q)) in $|
  |$\label{LFD:nex}$|      |$ \Let next = \deref (\Snd (\deref head)) in $|
  |$\label{LFD:hte}$|      |$ \If head = tail then $|
  |$\label{LFD:nen}$|        |$ \If next = \None then $|
  |$\label{LFD:non}$|          |$ \None $|
  |$\label{LFD:el1}$|        |$ \Else $|
  |$\label{LFD:stl}$|          |$ \CAS (\Snd (\deref Q)) \ tail \ next; loop \ \TT $|
  |$\label{LFD:el2}$|      |$ \Else $|
  |$\label{LFD:vde}$|        |$ \Let value = \Fst (\deref next) in $|
  |$\label{LFD:shs}$|        |$ \If \CAS \ (\Fst (\deref Q)) \ head \ next then $|
  |$\label{LFD:val}$|          |$ value $|
  |$\label{LFD:re1}$|        |$ \Else loop \ \TT $|
  |$\label{LFD:app}$|      |$ ) \TT $|
  \end{minted}
  \caption{Implementation of the \lfmsq{} in \heaplang.}
  \label{LFMSQ:implementation:code}
  \end{figure}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Proving that the Lock-and-CC-Free Michael-Scott Queue Satisfies the HOCAP-style Specification}

%=====================================================================
\begin{frame}{Reachability}
  \todo{create slide}
  % - Motivate why we need the notion:
  %   Captures important aspects of the queue that are essential for correctness
  %   Specifically:
  % + The linked list only ever grows (and at the end):
  %   The set of nodes that a particular node can reach only grows
  % + The head and tail are only moved forward in the linked list:
  %   If a node can reach current head/tail, can reach any future head/tail.
  % + The tail cannot lag behind the head
  % - Introduce Concrete and Abstract reachability to capture these Points
  % + Concrete reachability
  % * essentially a proposition of points-to predicates capturing a section of the linked list (kinda like isLL)
  % * Definition of Concrete reachability
  % + Abstract reachability
  % * Above talks about special ``types of nodes''
  % * head, tail, last
  % * Resource Algebra for Abstract Reachability
  % * Definition of Abstract Points-to
  % * Definition of Abstract Reachability
  % * The four lemmas
\end{frame}

%=====================================================================
\begin{frame}{Invariant}
  \todo{create slide}
  % - Need for invariant is same as for TLMSQ: need persistent queue predicate
  % - Show invariant
  % - head can ALWAYS abstractly reach tail. I.e. tail never lags behind
\end{frame}

%=====================================================================
\begin{frame}{Queue Predicate}
  \todo{create slide}
  % - Show predicate
  % - Queue predicate is persistent
  % - Proving that LFMSQ satisfies HOCAP spec then consists of proving the Hoare triples for initialise, enqueue, and dequeue.
  % - We here focus on initialise and \todo{enqueue xor dequeue}
\end{frame}

%=====================================================================
\begin{frame}{Proof of $\initialise$ and \todo{$\enqueue$ xor $\dequeue$}}
  \begin{center}
    {\fontsize{40}{60}\selectfont In Coq!}\\
  \end{center}
  \begin{center}
    \includegraphics[width=0.15\textwidth]{coq-logo-large.png}
  \end{center}
  % go over contents of file, but skip swing tail proof, and many of the results about reachability.
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
